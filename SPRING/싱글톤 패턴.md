## 📚 스프링 핵심 원리 - 기본편 (김영한)
##  ◆ 싱글톤 패턴
## 📌 스프링에서의 싱글톤 패턴
### 정의:
스프링은 개발자가 별도의 설정을 하지 않는 한, 컨테이너에 등록되는 모든 빈(Bean)을 기본적으로 싱글톤으로 
생성하고 관리한다. 이는 스프링이 제공하는 강력한 기능의 기반이 되며, 애플리케이션의 성능과 효율성을 높이는 데 
결정적인 역할을 한다.

### 일반적인 디자인 패턴으로서의 싱글톤:
싱글톤 패턴은 객체의 인스턴스가 오직 하나만 생성되도록 보장하는 디자인 패턴이다. 즉, 애플리케이션 전체에서 
해당 클래스의 인스턴스는 단 하나뿐이며, 어디서든 그 유일한 인스턴스에 접근할 수 있도록 하는 것이 목적이다.
전통적인 싱글톤 패턴 구현 방식은 보통 다음과 같다.
- 생성자를 ```private```으로 선언하여 외부에서 ```new``` 키워드로 객체를 생성하는 것을 막는다.
- 클래스 내부에 유일한 인스턴스를 저장할 ```static``` 변수를 선언한다.
- 외부에서 이 유일한 인스턴스에 접근할 수 있도록 ```static``` 메소드(보통 getInstance())를 제공한다.

### 스프링의 싱글톤 구현, 관리 방법:
스프링은 전통적인 싱글톤 패턴 구현 방식의 문제점(클래스 간의 높은 결합도, 테스트의 어려움)을 
해결하면서 싱글톤의 이점을 극대화하는 독자적인 방식을 사용한다.
핵심은 스프링 컨테이너, 즉 ```ApplicationContext```에 있다.
- 싱글톤 레지스트리: 스프링 컨테이너는 내부에 빈 객체들을 저장하는 공간(일종의 캐시)을 가진다. 
컨테이너가 생성될 때, 설정 정보를 바탕으로 필요한 빈 객체들을 미리 생성하여 이 저장소에 등록하게 된다.
- 빈의 생성과 관리: 개발자가 특정 빈을 요청하면(의존성 주입 등), 스프링 컨테이너는 새로운 객체를 
생성하는 것이 아니라 싱글톤 레지스트리에 이미 등록된 유일한 인스턴스를 반환한다.
- 객체지향 원칙 준수: 스프링의 방식은 일반적인 싱글톤 패턴과 달리, 개발자가 ```private``` 생성자나 
```getInstance()``` 같은 코드를 직접 작성할 필요가 없다. 평범한 자바 클래스를 만들고 어노테이션을 붙이거나 
XML에 설정하기만 하면, 스프링 컨테이너가 알아서 해당 클래스의 싱글톤을 보장해준다.
<br></br>
 
결론적으로, 스프링에서 "빈이 싱글톤이다"라는 말은 "스프링 컨테이너가 관리하는 해당 빈의 인스턴스는 단 하나이며,
모든 의존성 주입 요청에 대해 동일한 그 인스턴스를 반환한다"는 의미이다.

### 스프링에서 싱글톤을 사용하는 이유:
- 메모리 효율성 및 성능 향상: 요청이 있을 때마다 새로운 객체를 생성하고 소멸시키는 것은 상당한 메모리 낭비와 성능 저하를 유발하게 된다.
특히 요청이 많은 웹 애플리케이션 환경에서는 그 부담이 더욱 커지는데, 싱글톤 패턴을 사용하면 최초 한 번만 객체를 생성하고 이후에는 계속 
재활용하므로, 메모리 사용량을 크게 줄이고 시스템 전반의 성능을 향상시킬 수 있다.
- 데이터 공유의 용이성: 애플리케이션 전역에서 공유해야 하는 설정 정보, 캐시, 커넥션 풀과 같은 자원이 있을 때, 싱글톤 객체에 이들을 저장해두면
어디서든 일관된 데이터에 손쉽게 접근할 수 있다.

### 스프링 싱글톤 사용 시의 핵심 주의사항:
싱글톤 빈은 여러 스레드에서 동시에 접근하여 공유될 수 있다. 만약 싱글톤 빈이 상태를 가지는(Stateful) 필드, 즉 멤버 변수를 가지고 있고,
여러 스레드가 이 값을 동시에 변경하려고 한다면 동시성 문제가 발생할 수 있다.
<br></br>
✨ 예시:
```java
@Component
public class StatefulService {

    private int price; // 상태를 가지는 필드 (문제 발생 지점)

    public void order(String name, int price) {
        System.out.println("주문자: " + name + " / 주문 금액: " + price);
        this.price = price; // 이 부분이 문제!
    }

    public int getPrice() {
        return price;
    }
}
```
위와 같은 서비스가 있고, 스레드 A가 order("A", 10000)를 호출하고, 거의 동시에 스레드 B가 order("B", 20000)를 호출했다고 가정해보자. 
스레드 A가 this.price를 10000으로 설정한 직후, 스레드 B가 20000으로 덮어써버릴 수 있다. 그 결과 스레드 A가 이후에 getPrice()를 호출하면 
기대했던 10000이 아닌 20000을 반환받는 심각한 문제가 발생하게 된다.

✨ 해결 방안:
<br>
이러한 동시성 문제를 피하기 위한 가장 좋은 방법은 싱글톤 빈을 무상태(Stateless)로 설계하는 것이다.
- 특정 클라이언트에 의존적인 필드를 가지지 않도록 한다.
- 읽기 전용 값(수정 불가)만 사용한다.
- 필드 대신 메소드의 지역 변수, 파라미터, 리턴 값을 사용한다. 이들은 각 스레드마다 별도의 스택 메모리 영역에 생성되므로 
다른 스레드와 공유되지 않는다.
```java
@Component
public class StatelessService {

    // 상태를 가지는 필드가 없음 (Stateless)

    public int order(String name, int price) {
        System.out.println("주문자: " + name + " / 주문 금액: " + price);
        // price는 파라미터로 받아 바로 사용하고 소멸되므로 안전하다.
        return price;
    }
}
```
---





